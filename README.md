# Magnum Opus
The project is named after the alchemical term Magnum Opus (latin for: The Grand Work), as it is my greatest project up to date and the completion of it shall bring me understanding of higher realms (the AWS cloud).

## In this Project
In essence, Magnum Opus is an IaaC implementation of a minimal system on AWS EKS (Elastic Kubernetes Service). Terraform is used to define both AWS resources and Kubernetes API objects. Terraform configuratoin is summarized in a different MD file in this project (generated by [terraform-docs](https://terraform-docs.io/)).

### AWS Resources
Most AWS resources are defined using the Terraform "EKS" module. To learn more, check the official module [documentation](https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest).
below is a list of the primary resources:
* 2 EC2 instances (t3.small) to serve as Kubernetes nodes.
* An Auto Scaling Group to manage nodes.
* An EKS cluster.
* IAM roles and policy associations for reader and admin roles.
* Security groups to regulate traffic in and out of the cluster. 

In addition, standard networking objects are created, and will be listed here in full:
* Virtual Private Network (VPC)
* 2 private subnets in different Availability Zones, to host each EC2 instance.
* An internet Gateway, to allow public access into the nodes.
* A route table to associate the internet gateway with each of the subnets. 

Finally, applying the nginx-ingress controller manifest automatically creates an AWS **Application Load Balancer** that is routed to our nginx service. The creation of the load balancer is configured in the manifest itself.

### Kubernetes API Resources
As mentioned above, this project utilizes the Terraform Kubernetes provided to create API service, though this is not currently considered a good practice.
below are the workloads created in the cluster:
*  Postgres Database (Stateful Set)
* CRUD Service (Deployment)
* Nginx Server (Deployment)

A **configmap** and **secret** are created to store details and crednetials for Postgres. Each workload has a service connected to it to allow communication and load-balancing, and an ingress to route traffic to the CRUD service.

## Using This Project
To deploy Magnum Opus on AWS, first make sure you fulfill the following requirements.

### Credentials
verify your AWS credentials are [configured locally](https://docs.aws.amazon.com/cli/v1/userguide/cli-configure-files.html), and you have sufficient permissions to create the resources discussed here.

### Regional Service Availability
Not all services are supported in every AWS Region. To make sure your region supports the services used in this project, check the [official documentation](https://aws.amazon.com/about-aws/global-infrastructure/regional-product-services/).

### Local Tools
This project uses **Terraform** to deploy a **Kubernetes** cluster on **AWS**. In order to install the project properly, make sure the following command line tools are present on your machine:
* [kubectl](https://kubernetes.io/docs/tasks/tools/)
* [aws cli](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)
* [terraform](https://developer.hashicorp.com/terraform/install) 

### Installation
Once all requirements are set, simply follow these steps:
1. In the root directory, perform the command
`terraform apply --auto-approve`
to set the EKS infrastructure. This will skip the plan phase without prompting for confirmation. It make take some time before all resources are applied.

2. Change directory to the `kubernetes` folder, and perform 
`kubectl apply -f nginx.yaml`. 
This will create all API resources associated with Nginx.

3. For the final step, perform 
`terraform apply --auto-approve --var postgres_username=<your-postgres-username> --var postgres_password=<your-postgres-password>`.

Please note these are sensitive credentials. Make sure to insert these values in a safe method. 
This step must come after install Nginx because in this part we are creating an Ingress object, which is dependent of Nginx.

## Github Actions
The process described in the installation section is implemented as a Github Actions workflow that runs on `main` and `dev` branches.
